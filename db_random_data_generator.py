""" db_random_data_generator is used to insert random data into
    a sql server database for testing purposes"""
import string
import random
import time
import uuid
from typing import List
import argparse
import pyodbc


class FuzzerRow():
    """FuzzerRow holds data that is later used to generate random data for db rows"""
    def __init__(self, name="", length=0, precision=0, rowtype=""):
        self.col_name = name
        self.randomgen_length = length
        self.randomgen_precision = precision
        self.randomgen_type = rowtype

    def __str__(self):
        rand_val = self.get_random_value()
        length = self.randomgen_length
        rowtype = self.randomgen_type
        precision = self.randomgen_precision
        col_name = self.col_name
        return f'{col_name}({rowtype}:({length}, {precision}): {rand_val}'

    def get_random_value(self):
        """get_random_value returns a random value for the FuzzerRow,
        based on the datatype information
        received from the database"""
        funcs = {
            "varchar": lambda: self._rand_string(self.randomgen_length),
            "char": lambda: self._rand_string(self.randomgen_length),
            "bit": self._rand_bool,
            "uniqueidentifier": self._rand_unique_id,
            "datetime": self._rand_date,
            "int": lambda: self._rand_int(self.randomgen_length),
            "numeric": lambda: self._rand_numeric(self.randomgen_precision)
        }
        func = funcs.get(self.randomgen_type)
        return func()

    # Random Generation Functions
    def _rand_string(self, length):
        """rand_string is a utility function to generate a random string that has
         a length <= the provided length"""
        if length > 0:
            chars = string.ascii_letters + string.digits
            ret_val = ''.join(random.choice(chars)
                              for x in range(random.randint(1, length)))
            return f"'{ret_val}'"
        else:
            return ''


    def _rand_int(self, num_bytes=4):
        """rand_int generates a random integer with a number of bytes specified by
        the target database. It takes a number of bytes that the integer is supposed to
        be."""
        lower_bound = -(2**(8*num_bytes - 1))
        upper_bound = (2**(8*num_bytes - 1)) - 1
        return random.randint(lower_bound, upper_bound)

    def _rand_numeric(self, digits=6):
        return random.randint(0, 10**digits - 1)

    def _rand_bool(self):
        return random.choice([1, 0])

    def _rand_date(self):
        start_time = time.mktime(time.strptime(
            "1/1/1985 00:00:01", '%m/%d/%Y %H:%M:%S'))
        end_time = time.mktime(time.strptime(
            "12/31/2050 23:59:59", '%m/%d/%Y %H:%M:%S'))
        ret_val = time.strftime('%m/%d/%Y %H:%M:%S', time.localtime(
            start_time + random.choice(range(int(end_time - start_time)))))
        return f"'{ret_val}'"

    def _rand_unique_id(self):
        uid = uuid.uuid1()
        return f"'{uid}'"

class Arguments:
    """A container for arguments received by the program. Generated by
        the argument parser"""
    server = ""
    dbase = ""
    username = ""
    password = ""
    table_name = ""
    only_return_sql = False

class DBConnection():
    """Manages an instance of a database connection"""

    def __init__(self, args: Arguments):
        self.connection_string = f'DRIVER={{SQL Server}};SERVER={args.server};'
        self.connection_string += f'DATABASE={args.db};UID={args.username};PWD={args.password}'


    def construct_fuzzer_rows(self, table_name):
        """construct_fuzzer_rows returns a list of FuzzerRow objects
        that is based on the table metadata returned by the database.
        The function takes in a database name"""
        query_rows = []
        conn = pyodbc.connect(self.connection_string)
        cursor = conn.cursor()
        sqltext = """SELECT cols.name, cols.max_length, cols.precision,
                        cols.is_nullable, t.name as type
                    FROM sys.tables as tabs
                    JOIN sys.columns as cols on tabs.object_id = cols.object_id
                    JOIN sys.types as t on cols.user_type_id = t.user_type_id
                    WHERE tabs.name = ?"""
        for row in cursor.execute(sqltext, table_name):
            query_rows.append(
                FuzzerRow(row.name, row.max_length, row.precision, row.type))
        return query_rows

    #TODO: handle cases when count is greater than the number of rows allowed by the sql server
    #NOTE: This may be handled by doing the check in this function, then looping over
    #it in another, private function.
    def construct_fuzzer_query(self, table_name: string, fuzzer_rows: List[FuzzerRow], count: int):
        """construct_fuzzer_query takes in the database table name,
        a List of FuzzerRow objects, and an int
        specifying how many rows you want to insert.
        The function returns a text sql query"""
        params = []
        vals_funcs = []
        vals_lines = []
        for row in fuzzer_rows:
            params.append(row.col_name)
            vals_funcs.append(row.get_random_value)
        params_string = ','.join(params)
        for _ in range(count):
            vals_funcs_returns = []
            for func in vals_funcs:
                vals_funcs_returns.append(str(func()))
            vals_lines.append('({lines})'.format(lines=','.join(vals_funcs_returns)))
        vals = ','.join(vals_lines)
        sql_text = f'INSERT INTO {table_name}({params_string}) VALUES {vals};'
        return sql_text


def parse_arguments():
    """Parses the command line arguments received by the program"""
    parser = argparse.ArgumentParser()
    tablehelp = """Pass the name of a table that you want to fill
                with random data"""
    parser.add_argument("table", help=tablehelp)

    dbhelp = """Pass the name of the database that you will be connecting
                to."""
    parser.add_argument("db", help=dbhelp)

    tablehelp = """The name of the server to connect to"""
    parser.add_argument("server", help=tablehelp)

    username_help = """The username used to connect to the database"""
    parser.add_argument("username", help=username_help)

    password_help = """the password used to connect to the database"""
    parser.add_argument("pword", help=password_help)

    sqltext_help = """Set this flag if you want to get sql text only"""
    parser.add_argument("--sqlText", action="store_true", help=sqltext_help)

    cargs = parser.parse_args()
    friendly_args = Arguments()
    friendly_args.dbase = cargs.db
    friendly_args.password = cargs.pword
    friendly_args.table_name = cargs.table
    friendly_args.username = cargs.username
    friendly_args.server = cargs.server
    friendly_args.only_return_sql = cargs.sqlText
    return friendly_args

if __name__ == "__main__":
    #TODO: convert this into a function to be called on run
    MYARGS = parse_arguments()
    CONNECTION = DBConnection(MYARGS)
    ROWS = CONNECTION.construct_fuzzer_rows(MYARGS.table_name)
    #TODO: parameterize the number of rows
    QUERY = CONNECTION.construct_fuzzer_query(MYARGS.table_name, ROWS, 50)
    print(QUERY)
